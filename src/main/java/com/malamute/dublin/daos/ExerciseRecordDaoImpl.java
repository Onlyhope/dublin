package com.malamute.dublin.daos;

import com.malamute.dublin.entities.ExerciseRecord;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;

import javax.sql.DataSource;
import java.sql.*;
import java.util.List;

@Primary // Tells Spring this is the Primary dependency to inject. Otherwise it won't know between the two.
@Repository
public class ExerciseRecordDaoImpl implements ExerciseRecordDao {

    private final Logger log = LoggerFactory.getLogger(ExerciseRecordDaoImpl.class);
    private final DataSource dataSource;

    @Autowired
    public ExerciseRecordDaoImpl(DataSource dataSource) {
        log.info("Injecting {} implementation", this.getClass().getSimpleName());
        // Constructor injected Data Source
        // Configuration is located in the application.yml
//        this.dataSource = dataSource;

        // Manual Configuration
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1");
        config.setDriverClassName("org.h2.Driver");
        config.setUsername("sa");
        config.setPassword("");
        // Hardcoded dependency to the following Data Source
        this.dataSource = new HikariDataSource(config);
    }

    @Override
    public ExerciseRecord save(ExerciseRecord exerciseRecord) {

        String query = "insert into exercise_record (exercise_name, created_date, completed_date) values (?, ?, ?)";

        Connection con = null;
        PreparedStatement ps = null;

        try {
            con = dataSource.getConnection();
            ps = con.prepareStatement(query, Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, exerciseRecord.getExerciseName());
            ps.setTimestamp(2, exerciseRecord.getCreatedDate());
            ps.setTimestamp(3, exerciseRecord.getCompletedDate());
            int status = ps.executeUpdate();

            if (status == 0) {
                throw new SQLException("Error saving exercise record");
            }

            try (ResultSet generatedKeys = ps.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    long autoGeneratedId = generatedKeys.getLong(1);
                    exerciseRecord.setExRecId(autoGeneratedId);
                    log.info("Auto generated key: {}", autoGeneratedId);
                } else {
                    throw new SQLException("Getting auto generated key failed...");
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                ps.close();
                con.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        return exerciseRecord;
    }

    @Override
    public ExerciseRecord update(ExerciseRecord exerciseRecord) {
        return null;
    }

    @Override
    public ExerciseRecord getById(Long id) {
        return null;
    }

    @Override
    public void deleteById(Long id) {

    }

    @Override
    public List<ExerciseRecord> getAll() {
        return null;
    }

}
